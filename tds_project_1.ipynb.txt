{
  "cells": [
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "-NuY6tAk8pHM",
        "outputId": "a94fd4fe-89ff-4fd3-fdd8-ac73c6ae8a25"
      },
      "outputs": [
        {
          "metadata": {
            "tags": null
          },
          "name": "stdout",
          "output_type": "stream",
          "text": [
            "Requirement already satisfied: requests in /usr/local/lib/python3.10/dist-packages (2.32.3)\n",
            "Requirement already satisfied: charset-normalizer<4,>=2 in /usr/local/lib/python3.10/dist-packages (from requests) (3.4.0)\n",
            "Requirement already satisfied: idna<4,>=2.5 in /usr/local/lib/python3.10/dist-packages (from requests) (3.10)\n",
            "Requirement already satisfied: urllib3<3,>=1.21.1 in /usr/local/lib/python3.10/dist-packages (from requests) (2.2.3)\n",
            "Requirement already satisfied: certifi>=2017.4.17 in /usr/local/lib/python3.10/dist-packages (from requests) (2024.8.30)\n"
          ]
        }
      ],
      "source": [
        "# Install required libraries (requests)\n",
        "!pip install requests\n",
        "\n",
        "# Import necessary libraries me\n",
        "import requests\n",
        "import csv\n",
        "from google.colab import files\n",
        "\n",
        "# Use Colab's input() function to securely input your GitHub Personal Access Token (PAT)\n",
        "GITHUB_TOKEN = input(\"Please enter your GitHub Personal Access Token: \")\n",
        "headers = {'Authorization': f'token {GITHUB_TOKEN}'}\n",
        "\n",
        "# Function to fetch GitHub users from Chicago with over 100 followers\n",
        "def fetch_users_in_chicago():\n",
        "    users = []\n",
        "    url = \"https://api.github.com/search/users?q=location:chicago+followers:>100&per_page=100\"\n",
        "\n",
        "    while url:\n",
        "        response = requests.get(url, headers=headers)\n",
        "        response_json = response.json()\n",
        "        users.extend(response_json['items'])  # Add users to the list\n",
        "\n",
        "        # Handling pagination using the 'Link' header\n",
        "        if 'next' in response.links:\n",
        "            url = response.links['next']['url']\n",
        "        else:\n",
        "            url = None\n",
        "\n",
        "    return users\n",
        "\n",
        "# Function to fetch detailed user information\n",
        "def fetch_user_details(username):\n",
        "    url = f\"https://api.github.com/users/{username}\"\n",
        "    response = requests.get(url, headers=headers)\n",
        "    return response.json()\n",
        "\n",
        "# Function to fetch repositories for a user (up to 500 repositories)\n",
        "def fetch_user_repos(username):\n",
        "    repos = []\n",
        "    url = f\"https://api.github.com/users/{username}/repos?per_page=100\"\n",
        "\n",
        "    while url:\n",
        "        response = requests.get(url, headers=headers)\n",
        "        repos.extend(response.json())  # Add repositories to the list\n",
        "\n",
        "        # Handling pagination using the 'Link' header\n",
        "        if 'next' in response.links:\n",
        "            url = response.links['next']['url']\n",
        "        else:\n",
        "            url = None\n",
        "\n",
        "    return repos\n",
        "\n",
        "# Helper function to clean company names\n",
        "def clean_company_name(company):\n",
        "    if company:\n",
        "        return company.strip().lstrip('@').upper()  # Remove @ and extra spaces, convert to uppercase\n",
        "    return ''\n",
        "\n",
        "# Write users data to CSV\n",
        "def write_users_csv(users):\n",
        "    with open('users.csv', mode='w', newline='') as file:\n",
        "        writer = csv.writer(file)\n",
        "        # Writing the headers\n",
        "        writer.writerow([\"login\", \"name\", \"company\", \"location\", \"email\", \"hireable\", \"bio\", \"public_repos\", \"followers\", \"following\", \"created_at\"])\n",
        "\n",
        "        for user in users:\n",
        "            writer.writerow([\n",
        "                user['login'],\n",
        "                user['name'],\n",
        "                clean_company_name(user.get('company', '')),\n",
        "                user['location'],\n",
        "                user.get('email', ''),\n",
        "                user.get('hireable', ''),\n",
        "                user.get('bio', ''),\n",
        "                user['public_repos'],\n",
        "                user['followers'],\n",
        "                user['following'],\n",
        "                user['created_at']\n",
        "            ])\n",
        "\n",
        "# Write repositories data to CSV\n",
        "def write_repos_csv(repos):\n",
        "    with open('repositories.csv', mode='w', newline='') as file:\n",
        "        writer = csv.writer(file)\n",
        "        writer.writerow([\"login\", \"full_name\", \"created_at\", \"stargazers_count\", \"watchers_count\", \"language\", \"has_projects\", \"has_wiki\", \"license_name\"])\n",
        "\n",
        "        for repo in repos:\n",
        "            writer.writerow([\n",
        "                repo['owner']['login'],\n",
        "                repo['full_name'],\n",
        "                repo['created_at'],\n",
        "                repo['stargazers_count'],\n",
        "                repo['watchers_count'],\n",
        "                repo['language'],\n",
        "                repo['has_projects'],\n",
        "                repo['has_wiki'],\n",
        "                repo['license']['key'] if repo.get('license') else 'No License'\n",
        "            ])\n",
        "\n",
        "# Main function to orchestrate the process\n",
        "def main():\n",
        "    # Fetch users in Chicago with more than 100 followers\n",
        "    users = fetch_users_in_chicago()\n",
        "    print(\"1 Fetching users function complete\")\n",
        "\n",
        "    # Fetch detailed information for each user\n",
        "    detailed_users = [fetch_user_details(user['login']) for user in users]\n",
        "    print(\"2 fetch_user_details complete\")\n",
        "\n",
        "    # Fetch repositories for each user\n",
        "    repos = []\n",
        "    for user in detailed_users:\n",
        "        user_repos = fetch_user_repos(user['login'])\n",
        "        repos.extend(user_repos)  # Collect all repositories\n",
        "    print(\"3 fetch_user_repos complete\")\n",
        "\n",
        "    # Write user and repository data to CSV files\n",
        "    write_users_csv(detailed_users)\n",
        "    print(\"4 write_users_csv complete\")\n",
        "\n",
        "    write_repos_csv(repos)\n",
        "    print(\"5 write_repos_csv complete\")\n",
        "\n",
        "print(\"Data scraping complete! CSV files generated.\")\n",
        "\n",
        "# Execute the main function\n",
        "main()\n",
        "\n",
        "# Download the CSV files to your local machine\n",
        "files.download('users.csv')\n",
        "files.download('repositories.csv')"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/",
          "height": 107
        },
        "id": "JEwdQCw_QKb4",
        "outputId": "f9947b10-b482-4b62-9db0-df1e65b39f95"
      },
      "outputs": [
        {
          "data": {
            "text/html": [
              "\n",
              "     <input type=\"file\" id=\"files-73dd4170-66f6-45b4-9e3e-de37abc8610c\" name=\"files[]\" multiple disabled\n",
              "        style=\"border:none\" />\n",
              "     <output id=\"result-73dd4170-66f6-45b4-9e3e-de37abc8610c\">\n",
              "      Upload widget is only available when the cell has been executed in the\n",
              "      current browser session. Please rerun this cell to enable.\n",
              "      </output>\n",
              "      <script>// Copyright 2017 Google LLC\n",
              "//\n",
              "// Licensed under the Apache License, Version 2.0 (the \"License\");\n",
              "// you may not use this file except in compliance with the License.\n",
              "// You may obtain a copy of the License at\n",
              "//\n",
              "//      http://www.apache.org/licenses/LICENSE-2.0\n",
              "//\n",
              "// Unless required by applicable law or agreed to in writing, software\n",
              "// distributed under the License is distributed on an \"AS IS\" BASIS,\n",
              "// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n",
              "// See the License for the specific language governing permissions and\n",
              "// limitations under the License.\n",
              "\n",
              "/**\n",
              " * @fileoverview Helpers for google.colab Python module.\n",
              " */\n",
              "(function(scope) {\n",
              "function span(text, styleAttributes = {}) {\n",
              "  const element = document.createElement('span');\n",
              "  element.textContent = text;\n",
              "  for (const key of Object.keys(styleAttributes)) {\n",
              "    element.style[key] = styleAttributes[key];\n",
              "  }\n",
              "  return element;\n",
              "}\n",
              "\n",
              "// Max number of bytes which will be uploaded at a time.\n",
              "const MAX_PAYLOAD_SIZE = 100 * 1024;\n",
              "\n",
              "function _uploadFiles(inputId, outputId) {\n",
              "  const steps = uploadFilesStep(inputId, outputId);\n",
              "  const outputElement = document.getElementById(outputId);\n",
              "  // Cache steps on the outputElement to make it available for the next call\n",
              "  // to uploadFilesContinue from Python.\n",
              "  outputElement.steps = steps;\n",
              "\n",
              "  return _uploadFilesContinue(outputId);\n",
              "}\n",
              "\n",
              "// This is roughly an async generator (not supported in the browser yet),\n",
              "// where there are multiple asynchronous steps and the Python side is going\n",
              "// to poll for completion of each step.\n",
              "// This uses a Promise to block the python side on completion of each step,\n",
              "// then passes the result of the previous step as the input to the next step.\n",
              "function _uploadFilesContinue(outputId) {\n",
              "  const outputElement = document.getElementById(outputId);\n",
              "  const steps = outputElement.steps;\n",
              "\n",
              "  const next = steps.next(outputElement.lastPromiseValue);\n",
              "  return Promise.resolve(next.value.promise).then((value) => {\n",
              "    // Cache the last promise value to make it available to the next\n",
              "    // step of the generator.\n",
              "    outputElement.lastPromiseValue = value;\n",
              "    return next.value.response;\n",
              "  });\n",
              "}\n",
              "\n",
              "/**\n",
              " * Generator function which is called between each async step of the upload\n",
              " * process.\n",
              " * @param {string} inputId Element ID of the input file picker element.\n",
              " * @param {string} outputId Element ID of the output display.\n",
              " * @return {!Iterable<!Object>} Iterable of next steps.\n",
              " */\n",
              "function* uploadFilesStep(inputId, outputId) {\n",
              "  const inputElement = document.getElementById(inputId);\n",
              "  inputElement.disabled = false;\n",
              "\n",
              "  const outputElement = document.getElementById(outputId);\n",
              "  outputElement.innerHTML = '';\n",
              "\n",
              "  const pickedPromise = new Promise((resolve) => {\n",
              "    inputElement.addEventListener('change', (e) => {\n",
              "      resolve(e.target.files);\n",
              "    });\n",
              "  });\n",
              "\n",
              "  const cancel = document.createElement('button');\n",
              "  inputElement.parentElement.appendChild(cancel);\n",
              "  cancel.textContent = 'Cancel upload';\n",
              "  const cancelPromise = new Promise((resolve) => {\n",
              "    cancel.onclick = () => {\n",
              "      resolve(null);\n",
              "    };\n",
              "  });\n",
              "\n",
              "  // Wait for the user to pick the files.\n",
              "  const files = yield {\n",
              "    promise: Promise.race([pickedPromise, cancelPromise]),\n",
              "    response: {\n",
              "      action: 'starting',\n",
              "    }\n",
              "  };\n",
              "\n",
              "  cancel.remove();\n",
              "\n",
              "  // Disable the input element since further picks are not allowed.\n",
              "  inputElement.disabled = true;\n",
              "\n",
              "  if (!files) {\n",
              "    return {\n",
              "      response: {\n",
              "        action: 'complete',\n",
              "      }\n",
              "    };\n",
              "  }\n",
              "\n",
              "  for (const file of files) {\n",
              "    const li = document.createElement('li');\n",
              "    li.append(span(file.name, {fontWeight: 'bold'}));\n",
              "    li.append(span(\n",
              "        `(${file.type || 'n/a'}) - ${file.size} bytes, ` +\n",
              "        `last modified: ${\n",
              "            file.lastModifiedDate ? file.lastModifiedDate.toLocaleDateString() :\n",
              "                                    'n/a'} - `));\n",
              "    const percent = span('0% done');\n",
              "    li.appendChild(percent);\n",
              "\n",
              "    outputElement.appendChild(li);\n",
              "\n",
              "    const fileDataPromise = new Promise((resolve) => {\n",
              "      const reader = new FileReader();\n",
              "      reader.onload = (e) => {\n",
              "        resolve(e.target.result);\n",
              "      };\n",
              "      reader.readAsArrayBuffer(file);\n",
              "    });\n",
              "    // Wait for the data to be ready.\n",
              "    let fileData = yield {\n",
              "      promise: fileDataPromise,\n",
              "      response: {\n",
              "        action: 'continue',\n",
              "      }\n",
              "    };\n",
              "\n",
              "    // Use a chunked sending to avoid message size limits. See b/62115660.\n",
              "    let position = 0;\n",
              "    do {\n",
              "      const length = Math.min(fileData.byteLength - position, MAX_PAYLOAD_SIZE);\n",
              "      const chunk = new Uint8Array(fileData, position, length);\n",
              "      position += length;\n",
              "\n",
              "      const base64 = btoa(String.fromCharCode.apply(null, chunk));\n",
              "      yield {\n",
              "        response: {\n",
              "          action: 'append',\n",
              "          file: file.name,\n",
              "          data: base64,\n",
              "        },\n",
              "      };\n",
              "\n",
              "      let percentDone = fileData.byteLength === 0 ?\n",
              "          100 :\n",
              "          Math.round((position / fileData.byteLength) * 100);\n",
              "      percent.textContent = `${percentDone}% done`;\n",
              "\n",
              "    } while (position < fileData.byteLength);\n",
              "  }\n",
              "\n",
              "  // All done.\n",
              "  yield {\n",
              "    response: {\n",
              "      action: 'complete',\n",
              "    }\n",
              "  };\n",
              "}\n",
              "\n",
              "scope.google = scope.google || {};\n",
              "scope.google.colab = scope.google.colab || {};\n",
              "scope.google.colab._files = {\n",
              "  _uploadFiles,\n",
              "  _uploadFilesContinue,\n",
              "};\n",
              "})(self);\n",
              "</script> "
            ],
            "text/plain": [
              "<IPython.core.display.HTML object>"
            ]
          },
          "metadata": {},
          "output_type": "display_data"
        },
        {
          "name": "stdout",
          "output_type": "stream",
          "text": [
            "Saving repositories.csv to repositories (1).csv\n",
            "Saving users.csv to users (1).csv\n"
          ]
        }
      ],
      "source": [
        "from google.colab import files\n",
        "uploaded = files.upload()"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "colab": {
          "background_save": true,
          "base_uri": "https://localhost:8080/"
        },
        "id": "fP0DKrkHQ5uT",
        "outputId": "69b97a81-eee6-4888-92a7-7016d625a982"
      },
      "outputs": [
        {
          "name": "stdout",
          "output_type": "stream",
          "text": [
            "         login              name                     company     location  \\\n",
            "0     cassidoo  Cassidy Williams                      GITHUB  Chicago, IL   \n",
            "1     felangel     Felix Angelov               SHOREBIRDTECH      Chicago   \n",
            "2       dabeaz     David Beazley                 DABEAZ, LLC      Chicago   \n",
            "3  sstephenson    Sam Stephenson                         NaN      Chicago   \n",
            "4  mattgodbolt      Matt Godbolt  AQUATIC CAPITAL MANAGEMENT  Chicago, IL   \n",
            "\n",
            "                  email hireable  \\\n",
            "0                   NaN      NaN   \n",
            "1  felangelov@gmail.com      NaN   \n",
            "2       dave@dabeaz.com      NaN   \n",
            "3          sam@sls.name      NaN   \n",
            "4      matt@godbolt.org      NaN   \n",
            "\n",
            "                                                 bio  public_repos  followers  \\\n",
            "0            Making memes and dreams... and software           165      13363   \n",
            "1  software engineer by day, software engineer by...           125       8668   \n",
            "2  Author of the Python Essential Reference (Addi...            34       5173   \n",
            "3                                                NaN            24       3762   \n",
            "4  Compiler Explorer and jsbeeb creator, ex-Googl...            84       3396   \n",
            "\n",
            "   following            created_at  \n",
            "0        102  2012-02-20T16:36:23Z  \n",
            "1         67  2014-09-22T02:35:58Z  \n",
            "2          0  2010-08-01T15:22:48Z  \n",
            "3          0  2008-03-08T22:17:24Z  \n",
            "4         97  2011-02-23T13:46:48Z  \n",
            "Top 5 users by followers:  cassidoo,felangel,dabeaz,sstephenson,mattgodbolt\n"
          ]
        }
      ],
      "source": [
        "# (Q1) Who are the top 5 users in Chicago with the highest number of followers? List their login in order, comma-separated.\n",
        "# Import necessary libraries\n",
        "import pandas as pd\n",
        "\n",
        "# Read the CSV files\n",
        "users_df = pd.read_csv('/content/users.csv')  # Adjust the path if necessary\n",
        "# Display the first few rows of the dataframe to verify data\n",
        "print(users_df.head())\n",
        "\n",
        "# Function to get the top 5 users with the highest number of followers\n",
        "def top_5_users_by_followers(users_df):\n",
        "    # Sort users by the number of followers in descending order\n",
        "    sorted_users = users_df.sort_values(by='followers', ascending=False)\n",
        "\n",
        "    # Extract the top 5 users\n",
        "    top_5 = sorted_users.head(5)\n",
        "\n",
        "    # Return their login names, comma-separated\n",
        "    top_5_logins = ','.join(top_5['login'].tolist())\n",
        "\n",
        "    return top_5_logins\n",
        "\n",
        "# Get the top 5 users by followers\n",
        "top_5_logins = top_5_users_by_followers(users_df)\n",
        "print(\"Top 5 users by followers: \", top_5_logins)"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "odg8kL7K_y5J",
        "outputId": "5792a4ae-027f-4b24-fcc7-c4b95197bd34"
      },
      "outputs": [
        {
          "name": "stdout",
          "output_type": "stream",
          "text": [
            "5 earliest registered users:  ELLIOTTCABLE,trevorturk,lukehoersten,djspiewak,shanesveller\n"
          ]
        }
      ],
      "source": [
        "# (Q2) Who are the 5 earliest registered GitHub users in Chicago? List their login in ascending order of created_at, comma-separated.\n",
        "# Function to get the 5 earliest registered users\n",
        "def earliest_5_users(users_df):\n",
        "    # Convert the 'created_at' column to datetime\n",
        "    users_df['created_at'] = pd.to_datetime(users_df['created_at'])\n",
        "\n",
        "    # Sort users by 'created_at' in ascending order\n",
        "    sorted_users = users_df.sort_values(by='created_at', ascending=True)\n",
        "\n",
        "    # Extract the top 5 earliest users\n",
        "    earliest_5 = sorted_users.head(5)\n",
        "\n",
        "    # Return their login names, comma-separated\n",
        "    earliest_5_logins = ','.join(earliest_5['login'].tolist())\n",
        "\n",
        "    return earliest_5_logins\n",
        "\n",
        "# Get the 5 earliest registered users\n",
        "earliest_5_logins = earliest_5_users(users_df)\n",
        "print(\"5 earliest registered users: \", earliest_5_logins)"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "m4-kImzfSGgB",
        "outputId": "4d4b2759-c7e1-458b-ebbe-6696eabbe3b4"
      },
      "outputs": [
        {
          "name": "stdout",
          "output_type": "stream",
          "text": [
            "3 most popular licenses:  No License,mit,other\n"
          ]
        }
      ],
      "source": [
        "# (Q3) Function to get the 3 most popular licenses\n",
        "# Read the repositories CSV file\n",
        "repos_df = pd.read_csv('/content/repositories.csv')  # Adjust the path if necessary\n",
        "\n",
        "# Function to get the 3 most popular licenses\n",
        "def top_3_popular_licenses(repos_df):\n",
        "    # Filter out missing licenses\n",
        "    filtered_licenses = repos_df['license_name'].dropna()\n",
        "\n",
        "    # Count the occurrences of each license\n",
        "    license_counts = filtered_licenses.value_counts()\n",
        "\n",
        "    # Get the top 3 licenses\n",
        "    top_3_licenses = license_counts.head(3)\n",
        "\n",
        "    # Return the license names, comma-separated\n",
        "    return ','.join(top_3_licenses.index.tolist())\n",
        "\n",
        "# Get the 3 most popular licenses\n",
        "top_3_licenses = top_3_popular_licenses(repos_df)\n",
        "print(\"3 most popular licenses: \", top_3_licenses)\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "gl4wRSQMSgAH",
        "outputId": "49d87fce-9114-4883-8b44-8dc25ab6dce9"
      },
      "outputs": [
        {
          "name": "stdout",
          "output_type": "stream",
          "text": [
            "The majority of developers work at: UNIVERSITY OF CHICAGO (Count: 12)\n"
          ]
        }
      ],
      "source": [
        "# (Q4) Read the users CSV file\n",
        "users_df = pd.read_csv('/content/users.csv')  # Adjust the path if necessary\n",
        "\n",
        "# Function to get the majority company\n",
        "def majority_company(users_df):\n",
        "    # Filter out missing company names\n",
        "    filtered_companies = users_df['company'].dropna()\n",
        "\n",
        "    # Count the occurrences of each company\n",
        "    company_counts = filtered_companies.value_counts()\n",
        "\n",
        "    # Get the company with the highest count\n",
        "    majority_company = company_counts.idxmax()  # Company name with the highest count\n",
        "    majority_count = company_counts.max()  # Count of developers in that company\n",
        "\n",
        "    return majority_company, majority_count\n",
        "\n",
        "# Get the majority company and its count\n",
        "company, count = majority_company(users_df)\n",
        "print(f\"The majority of developers work at: {company} (Count: {count})\")"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "tB5LJPckTr0k",
        "outputId": "23292813-229e-40ed-b896-0a4d9bc5efe1"
      },
      "outputs": [
        {
          "name": "stdout",
          "output_type": "stream",
          "text": [
            "The most popular programming language is: JavaScript (Count: 5507)\n"
          ]
        }
      ],
      "source": [
        "# (Q5)\n",
        "# Read the repositories CSV file\n",
        "repos_df = pd.read_csv('/content/repositories.csv')  # Adjust the path if necessary\n",
        "\n",
        "# Function to get the most popular programming language\n",
        "def most_popular_language(repos_df):\n",
        "    # Filter out missing languages\n",
        "    filtered_languages = repos_df['language'].dropna()\n",
        "\n",
        "    # Count the occurrences of each language\n",
        "    language_counts = filtered_languages.value_counts()\n",
        "\n",
        "    # Get the most popular language\n",
        "    most_popular_language = language_counts.idxmax()  # Language name with the highest count\n",
        "    most_popular_count = language_counts.max()  # Count of repositories in that language\n",
        "\n",
        "    return most_popular_language, most_popular_count\n",
        "\n",
        "# Get the most popular language and its count\n",
        "language, count = most_popular_language(repos_df)\n",
        "print(f\"The most popular programming language is: {language} (Count: {count})\")\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "0kSR-dIJT3Mv",
        "outputId": "08f1af61-1bf5-4b71-cf5f-de3b57231057"
      },
      "outputs": [
        {
          "name": "stdout",
          "output_type": "stream",
          "text": [
            "The second most popular programming language among users who joined after 2020 is: JavaScript (Count: 77)\n"
          ]
        }
      ],
      "source": [
        "# (Q6)\n",
        "# Read the users and repositories CSV files\n",
        "users_df = pd.read_csv('/content/users.csv')  # Adjust the path if necessary\n",
        "repos_df = pd.read_csv('/content/repositories.csv')  # Adjust the path if necessary\n",
        "\n",
        "# Function to get the second most popular language among users who joined after 2020\n",
        "def second_most_popular_language(users_df, repos_df):\n",
        "    # Convert 'created_at' to datetime\n",
        "    users_df['created_at'] = pd.to_datetime(users_df['created_at'])\n",
        "\n",
        "    # Filter users who joined after 2020\n",
        "    filtered_users = users_df[users_df['created_at'] > '2020-01-01']\n",
        "\n",
        "    # Get the logins of these users\n",
        "    logins_after_2020 = filtered_users['login'].tolist()\n",
        "\n",
        "    # Filter repositories by these users\n",
        "    filtered_repos = repos_df[repos_df['login'].isin(logins_after_2020)]\n",
        "\n",
        "    # Filter out missing languages\n",
        "    filtered_languages = filtered_repos['language'].dropna()\n",
        "\n",
        "    # Count the occurrences of each language\n",
        "    language_counts = filtered_languages.value_counts()\n",
        "\n",
        "    # Get the second most popular language\n",
        "    if len(language_counts) > 1:\n",
        "        second_most_popular_language = language_counts.index[1]  # Get the second most popular language\n",
        "        second_most_count = language_counts.iloc[1]  # Count of repositories in that language\n",
        "    else:\n",
        "        second_most_popular_language = None\n",
        "        second_most_count = 0\n",
        "\n",
        "    return second_most_popular_language, second_most_count\n",
        "\n",
        "# Get the second most popular language and its count\n",
        "language, count = second_most_popular_language(users_df, repos_df)\n",
        "if language:\n",
        "    print(f\"The second most popular programming language among users who joined after 2020 is: {language} (Count: {count})\")\n",
        "else:\n",
        "    print(\"Not enough data to determine the second most popular language.\")\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "848G75gwUC-v",
        "outputId": "e8d440fa-1e33-4c8a-fced-d49b324bb092"
      },
      "outputs": [
        {
          "name": "stdout",
          "output_type": "stream",
          "text": [
            "The programming language with the highest average number of stars per repository is: Vim Script (Average Stars: 647.14)\n"
          ]
        }
      ],
      "source": [
        "# (Q7)\n",
        "# Read the repositories CSV file\n",
        "repos_df = pd.read_csv('/content/repositories.csv')  # Adjust the path if necessary\n",
        "\n",
        "# Function to find the language with the highest average number of stars per repository\n",
        "def language_with_highest_avg_stars(repos_df):\n",
        "    # Filter out missing languages and stars\n",
        "    filtered_repos = repos_df[['language', 'stargazers_count']].dropna()\n",
        "\n",
        "    # Group by language and calculate the average number of stars\n",
        "    avg_stars = filtered_repos.groupby('language')['stargazers_count'].mean()\n",
        "\n",
        "    # Get the language with the highest average stars\n",
        "    highest_avg_language = avg_stars.idxmax()  # Language with the highest average stars\n",
        "    highest_avg_count = avg_stars.max()  # Average number of stars for that language\n",
        "\n",
        "    return highest_avg_language, highest_avg_count\n",
        "\n",
        "# Get the language with the highest average stars\n",
        "language, avg_stars = language_with_highest_avg_stars(repos_df)\n",
        "print(f\"The programming language with the highest average number of stars per repository is: {language} (Average Stars: {avg_stars:.2f})\")\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "XjdIBnAhUoy5",
        "outputId": "9bef9bbc-28c7-46c3-81f9-2d5110cfea24"
      },
      "outputs": [
        {
          "name": "stdout",
          "output_type": "stream",
          "text": [
            "The top 5 users in terms of leader_strength are: dabeaz,sstephenson,khan4019,adashofdata,djspiewak\n"
          ]
        }
      ],
      "source": [
        "# (Q8)\n",
        "# Read the users CSV file\n",
        "users_df = pd.read_csv('/content/users.csv')  # Adjust the path if necessary\n",
        "\n",
        "# Calculate leader_strength\n",
        "users_df['leader_strength'] = users_df['followers'] / (1 + users_df['following'])\n",
        "\n",
        "# Get the top 5 users by leader_strength\n",
        "top_leaders = users_df.nlargest(5, 'leader_strength')[['login', 'leader_strength']]\n",
        "\n",
        "# Prepare the output as a comma-separated string\n",
        "top_leader_logins = ','.join(top_leaders['login'].tolist())\n",
        "\n",
        "print(f\"The top 5 users in terms of leader_strength are: {top_leader_logins}\")\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "2arLMH9yU4uV",
        "outputId": "bebc2c91-c295-4a66-eabd-5b3dd39ffee8"
      },
      "outputs": [
        {
          "name": "stdout",
          "output_type": "stream",
          "text": [
            "The correlation between the number of followers and the number of public repositories is: 0.083\n"
          ]
        }
      ],
      "source": [
        "# (Q9)\n",
        "# Read the users CSV file\n",
        "users_df = pd.read_csv('/content/users.csv')  # Adjust the path if necessary\n",
        "\n",
        "# Calculate the correlation between followers and public repositories\n",
        "correlation = users_df['followers'].corr(users_df['public_repos'])\n",
        "\n",
        "# Print the correlation rounded to 3 decimal places\n",
        "print(f\"The correlation between the number of followers and the number of public repositories is: {correlation:.3f}\")"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "BC-HfPelVG3T",
        "outputId": "f7a2f896-b62e-46bd-b1d5-cd4f3655fed6"
      },
      "outputs": [
        {
          "name": "stdout",
          "output_type": "stream",
          "text": [
            "The regression slope of followers on public repositories is: 0.685\n"
          ]
        }
      ],
      "source": [
        "# (Q10)\n",
        "# Import the required library for linear regression\n",
        "from scipy import stats\n",
        "\n",
        "# Read the users CSV file\n",
        "users_df = pd.read_csv('/content/users.csv')  # Adjust the path if necessary\n",
        "\n",
        "# Perform linear regression to find the slope\n",
        "slope, intercept, r_value, p_value, std_err = stats.linregress(users_df['public_repos'], users_df['followers'])\n",
        "\n",
        "# Print the slope rounded to 3 decimal places\n",
        "print(f\"The regression slope of followers on public repositories is: {slope:.3f}\")\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "BNABf_BPVQik",
        "outputId": "8c27a33c-6ae3-465c-992a-ec5920c899a9"
      },
      "outputs": [
        {
          "name": "stdout",
          "output_type": "stream",
          "text": [
            "The correlation between having projects enabled and having a wiki enabled is: 0.287\n"
          ]
        },
        {
          "name": "stderr",
          "output_type": "stream",
          "text": [
            "<ipython-input-24-84be481f6fc7>:9: FutureWarning: Downcasting behavior in `replace` is deprecated and will be removed in a future version. To retain the old behavior, explicitly call `result.infer_objects(copy=False)`. To opt-in to the future behavior, set `pd.set_option('future.no_silent_downcasting', True)`\n",
            "  repos_df['has_projects'] = repos_df['has_projects'].replace({True: 1, False: 0})\n",
            "<ipython-input-24-84be481f6fc7>:10: FutureWarning: Downcasting behavior in `replace` is deprecated and will be removed in a future version. To retain the old behavior, explicitly call `result.infer_objects(copy=False)`. To opt-in to the future behavior, set `pd.set_option('future.no_silent_downcasting', True)`\n",
            "  repos_df['has_wiki'] = repos_df['has_wiki'].replace({True: 1, False: 0})\n"
          ]
        }
      ],
      "source": [
        "# (Q11)\n",
        "# Import necessary libraries\n",
        "import pandas as pd\n",
        "\n",
        "# Read the repositories CSV file\n",
        "repos_df = pd.read_csv('/content/repositories.csv')  # Adjust the path if necessary\n",
        "\n",
        "# Convert has_projects and has_wiki to binary (1 for True, 0 for False)\n",
        "repos_df['has_projects'] = repos_df['has_projects'].replace({True: 1, False: 0})\n",
        "repos_df['has_wiki'] = repos_df['has_wiki'].replace({True: 1, False: 0})\n",
        "\n",
        "# Calculate the correlation between has_projects and has_wiki\n",
        "correlation = repos_df['has_projects'].corr(repos_df['has_wiki'])\n",
        "\n",
        "# Print the correlation rounded to 3 decimal places\n",
        "print(f\"The correlation between having projects enabled and having a wiki enabled is: {correlation:.3f}\")"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "HM-YBcjVVbU_",
        "outputId": "720f8347-a5bc-4670-9a87-adadaa0eb43b"
      },
      "outputs": [
        {
          "name": "stdout",
          "output_type": "stream",
          "text": [
            "The difference in average following between hireable and non-hireable users is: nan\n"
          ]
        }
      ],
      "source": [
        "# (Q12)\n",
        "# Import necessary libraries\n",
        "import pandas as pd\n",
        "\n",
        "# Read the users CSV file\n",
        "users_df = pd.read_csv('/content/users.csv')  # Adjust the path if necessary\n",
        "\n",
        "# Calculate average following for hireable users (hireable == True)\n",
        "avg_following_hireable = users_df[users_df['hireable'] == True]['following'].mean()\n",
        "\n",
        "# Calculate average following for non-hireable users (hireable == False)\n",
        "avg_following_non_hireable = users_df[users_df['hireable'] == False]['following'].mean()\n",
        "\n",
        "# Calculate the difference between the two averages\n",
        "difference = avg_following_hireable - avg_following_non_hireable\n",
        "\n",
        "# Print the result rounded to 3 decimal places\n",
        "print(f\"The difference in average following between hireable and non-hireable users is: {difference:.3f}\")\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "i4eiLduKV2Uz",
        "outputId": "ecf0ac95-36dc-46e9-bac4-ffa527a4655c"
      },
      "outputs": [
        {
          "name": "stdout",
          "output_type": "stream",
          "text": [
            "The regression slope of followers on bio word count is: 2.773\n"
          ]
        },
        {
          "name": "stderr",
          "output_type": "stream",
          "text": [
            "<ipython-input-26-4e56e8c118e6>:14: SettingWithCopyWarning: \n",
            "A value is trying to be set on a copy of a slice from a DataFrame.\n",
            "Try using .loc[row_indexer,col_indexer] = value instead\n",
            "\n",
            "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",
            "  bio_users_df['bio_length'] = bio_users_df['bio'].apply(lambda x: len(x.split()))\n"
          ]
        }
      ],
      "source": [
        "# (Q13)\n",
        "# Import necessary libraries\n",
        "import pandas as pd\n",
        "import numpy as np\n",
        "from sklearn.linear_model import LinearRegression\n",
        "\n",
        "# Read the users CSV file\n",
        "users_df = pd.read_csv('/content/users.csv')  # Adjust the path if necessary\n",
        "\n",
        "# Filter out users without bios\n",
        "bio_users_df = users_df[users_df['bio'].notnull()]\n",
        "\n",
        "# Calculate bio length in words\n",
        "bio_users_df['bio_length'] = bio_users_df['bio'].apply(lambda x: len(x.split()))\n",
        "\n",
        "# Prepare the data for regression\n",
        "X = bio_users_df[['bio_length']].values  # Independent variable (bio length)\n",
        "y = bio_users_df['followers'].values  # Dependent variable (followers)\n",
        "\n",
        "# Create and fit the linear regression model\n",
        "model = LinearRegression()\n",
        "model.fit(X, y)\n",
        "\n",
        "# Get the slope of the regression line (coefficient)\n",
        "slope = model.coef_[0]\n",
        "\n",
        "# Print the slope rounded to 3 decimal places\n",
        "print(f\"The regression slope of followers on bio word count is: {slope:.3f}\")\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "h-n950yMWCNS",
        "outputId": "512f052a-0aa1-4522-c842-9958fd61930b"
      },
      "outputs": [
        {
          "name": "stdout",
          "output_type": "stream",
          "text": [
            "Top 5 users who created the most repositories on weekends (UTC): marwahaha,austinsonger,eddelbuettel,sabre1041,yyolk\n"
          ]
        }
      ],
      "source": [
        "# (Q14)\n",
        "# Import necessary libraries\n",
        "import pandas as pd\n",
        "\n",
        "# Read the repositories CSV file\n",
        "repos_df = pd.read_csv('/content/repositories.csv')  # Adjust the path if necessary\n",
        "\n",
        "# Convert created_at to datetime\n",
        "repos_df['created_at'] = pd.to_datetime(repos_df['created_at'])\n",
        "\n",
        "# Filter for weekends (Saturday and Sunday)\n",
        "repos_df['is_weekend'] = repos_df['created_at'].dt.dayofweek >= 5  # 5: Saturday, 6: Sunday\n",
        "\n",
        "# Count the number of repositories created on weekends by each user\n",
        "weekend_repos_count = repos_df[repos_df['is_weekend']].groupby('login').size()\n",
        "\n",
        "# Get the top 5 users with the most weekend repositories\n",
        "top_weekend_users = weekend_repos_count.nlargest(5)\n",
        "\n",
        "# Get the logins of the top users\n",
        "top_weekend_logins = top_weekend_users.index.tolist()\n",
        "\n",
        "# Print the top 5 users' logins in order, comma-separated\n",
        "print(\"Top 5 users who created the most repositories on weekends (UTC):\", ','.join(top_weekend_logins))"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "3XSRdi7jWOth",
        "outputId": "d2ed519c-cf8b-462e-d6f6-99a8868092d3"
      },
      "outputs": [
        {
          "name": "stdout",
          "output_type": "stream",
          "text": [
            "Difference in fractions of users with email: nan\n"
          ]
        }
      ],
      "source": [
        "# (Q15)\n",
        "# Import necessary libraries\n",
        "import pandas as pd\n",
        "\n",
        "# Read the users CSV file\n",
        "users_df = pd.read_csv('/content/users.csv')  # Adjust the path if necessary\n",
        "\n",
        "# Calculate fraction of users with email when hireable=true\n",
        "hireable_users = users_df[users_df['hireable'] == True]\n",
        "fraction_hireable_with_email = hireable_users['email'].notnull().mean()\n",
        "\n",
        "# Calculate fraction of users with email when hireable=false\n",
        "non_hireable_users = users_df[users_df['hireable'] == False]\n",
        "fraction_non_hireable_with_email = non_hireable_users['email'].notnull().mean()\n",
        "\n",
        "# Calculate the difference\n",
        "difference = fraction_hireable_with_email - fraction_non_hireable_with_email\n",
        "\n",
        "# Print the result rounded to 3 decimal places\n",
        "print(f\"Difference in fractions of users with email: {difference:.3f}\")\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "sKfkVU2nWdh6",
        "outputId": "e2253e17-d4d2-4b85-cb50-09564444594d"
      },
      "outputs": [
        {
          "name": "stdout",
          "output_type": "stream",
          "text": [
            "Most common surname(s): Baker,Chen,Chu,Fuller,James,Jones,King,LLC,Miller,Olsen,Sadykov,Smith,Turk,Xavier,Zhang\n",
            "Number of users with the most common surname: 2\n"
          ]
        }
      ],
      "source": [
        "# Q(16)\n",
        "# Import necessary libraries\n",
        "import pandas as pd\n",
        "\n",
        "# Read the users CSV file\n",
        "users_df = pd.read_csv('/content/users.csv')  # Adjust the path if necessary\n",
        "\n",
        "# Extract surnames (last word in the name, ignoring missing names)\n",
        "# Strip whitespace, dropna(), and then split by space to get the last element\n",
        "surnames = users_df['name'].dropna().str.strip().str.split().str[-1]\n",
        "\n",
        "# Count occurrences of each surname\n",
        "surname_counts = surnames.value_counts()\n",
        "\n",
        "# Find the maximum count of surnames\n",
        "max_count = surname_counts.max()\n",
        "\n",
        "# Get the most common surname(s)\n",
        "most_common_surnames = surname_counts[surname_counts == max_count].index.tolist()\n",
        "\n",
        "# Sort the surnames alphabetically\n",
        "most_common_surnames.sort()\n",
        "\n",
        "# Print the results\n",
        "print(f\"Most common surname(s): {','.join(most_common_surnames)}\")\n",
        "print(f\"Number of users with the most common surname: {max_count}\")"
      ]
    }
  ],
  "metadata": {
    "colab": {
      "provenance": []
    },
    "kernelspec": {
      "display_name": "Python 3",
      "name": "python3"
    },
    "language_info": {
      "name": "python"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 0
}